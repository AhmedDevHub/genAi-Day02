# QuickSort Lab: Copilot-Assisted Development Process

## How Copilot Assisted
- **Code Generation:** Copilot suggested initial implementations for QuickSort, MergeSort, HeapSort, and their variants.
- **Code Enhancement:** Copilot provided ideas for in-place and iterative optimizations, and helped refactor code for clarity.
- **Testing:** Copilot generated unit tests for all sorting algorithms, covering edge cases and large datasets.
- **Documentation:** Copilot helped write clear explanations and Markdown documentation for each algorithm and comparison.
- **UI & Benchmarking:** Copilot assisted in creating a simple web interface and benchmarking script for performance analysis.

## Performance Comparisons
- **QuickSort (recursive, in-place, iterative):** Fast for most cases, but recursive version can hit stack limits on very large arrays.
- **MergeSort:** Consistently O(n log n), stable, but uses more memory.
- **HeapSort:** In-place and O(n log n), but not stable and usually a bit slower than QuickSort or MergeSort.
- **Built-in Array.sort:** Highly optimized and stable in modern JavaScript engines; usually the fastest and most reliable for general use.

## Key Learnings
- **Algorithm Choice Matters:** Different algorithms have trade-offs in speed, memory, and stability.
- **In-Place vs. Not In-Place:** In-place algorithms save memory but can be harder to understand for beginners.
- **Testing is Crucial:** Unit tests catch edge cases and ensure correctness across all scenarios.
- **Copilot as a Partner:** Copilot accelerates development, offers suggestions, and helps with documentation, but reviewing and understanding the code is essential.
- **UI and Benchmarking:** Simple interfaces and benchmarks make it easy to interact with and compare algorithms.

---

This lab demonstrated how Copilot can be used throughout the software development lifecycle, from code generation to testing, documentation, and performance analysis. 